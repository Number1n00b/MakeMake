import sys

# ========== Self Defined Errors ============
class InvalidFileFormatError(Exception):
    def __init__(self, message):
        super().__init__(message)

# ===== Valid Configuration File Flags ======
VALID_CONFIG_FLAGS = {":ENVIRONMENT:" : ":END_ENVIRONMENT:", ":VARS:" : ":END_VARS:" , ":TESTS:" : ":END_TESTS:", ":ALLWAYS:" : ":END_ALLWAYS:"}

# ============= Main Program ================

# Command line arguments: (Will override defaults, and everything in config file)
# --root-dir
# --src-dir
# --config-file
# --output-name
DEFAULT_CONFIG_FILE_NAME = "smol.cfg"

def main():
    print("Running MakeMake...")

    config_file_name = DEFAULT_CONFIG_FILE_NAME

    # @TODO be more robust in parsing command line args, and parse the rest too.
    # (Right now we're just checking that the first arg is the config file name)
    if len(sys.argv) == 1 or sys.argv[1].startswith("-"):
        print("Using default config file.")
    else:
        config_file_name = sys.argv[1]

    print("Attempting to parse config file '{}'...".format(config_file_name))

    config, using_default = parse_config_file(config_file_name)

    if using_default:
        # Use all defaults.
        print("Creating default makefile...")
    else:
        # Use the config.
        print("Creating makefile based on config file...")

    create_makefile(config)

    return 0


# ====== Makefile Creation Functions =======
def create_makefile(config):
    with open(config[":ENVIRONMENT:"]["MAKEFILE_NAME"], "r") as makefile:
        makefile.write("# This file was auto-generated by MakeMake.py\nad")
        makefile.write("ss")




# ======= Config Parsing Functions =========

# Returns: config, using_defaults
#            dict, bool
def parse_config_file(config_file_name):
    config = get_default_config()
    using_default = False

    try:
        contents = []
        with open(config_file_name, "r") as f:
            for line in f:
                contents.append(line.strip("\n"))

        if len(contents) == 0:
            print("Warning: config file is empty.")
            using_default = True
            return config, using_default

        curr_line_number = 0
        flag_line_number = 0
        exit_flag_line_number = 0

        while(curr_line_number < len(contents)):
            # Ignore blank lines because they are not inside a flag block.
            curr_line_number = eat_empty_lines(contents, curr_line_number)
            curr_line = contents[curr_line_number]

            # Ignore all lines starting with a '#' outside of flag blocks.
            if curr_line.startswith('#'):
                curr_line_number += 1
                continue

            # Check if the flag is valid.
            if curr_line not in VALID_CONFIG_FLAGS.keys():
                msg = "Config file has incorrect format. Flag '{}' is invalid. (Or text outside of flag block).".format(curr_line)
                raise InvalidFileFormatError(msg)
            else:
                flag_line_number = curr_line_number
                exit_flag_line_number = find_exit_flag(contents, curr_line_number, VALID_CONFIG_FLAGS[curr_line])

                if not exit_flag_line_number:
                    msg = "Config file has incorrect format. Flag '{}' has no exit flag ('{}').".format(curr_line, VALID_CONFIG_FLAGS[curr_line])
                    raise InvalidFileFormatError(msg)

                parse_flag_contents(config, contents, flag_line_number, exit_flag_line_number)
                curr_line_number = exit_flag_line_number + 1

    except FileNotFoundError as e:
        print("\tConfig file '{}' not found.".format(config_file_name))
        using_default = True

    except InvalidFileFormatError as e:
        print("\t", e, sep="")
        using_default = True

        # Since the file didn't parse correctly, set the config back to defaults.
        config = get_default_config()

    return config, using_default


def eat_empty_lines(contents, curr_line_number):
    while(curr_line_number < len(contents) and len(contents[curr_line_number]) == 0):
        curr_line_number += 1

    return curr_line_number


def find_exit_flag(contents, curr_line_number, exit_flag):
    while curr_line_number < len(contents) - 1 and not contents[curr_line_number] == exit_flag:
        curr_line_number += 1

    if contents[curr_line_number] == exit_flag:
        return curr_line_number
    else:
        return None


def get_default_config():
    config = {}

    # Set up environment variables.
    env_vars = {}

    env_vars["PROJ_ROOT_DIR"] = "."
    env_vars["PROJ_SRC_DIR"]  = env_vars["PROJ_ROOT_DIR"] + "/src"

    env_vars["MAKEFILE_NAME"] = "Makefile"

    config[":ENVIRONMENT:"] = env_vars

    # Set up makefile variables.
    vars = {}

    config[":VARS:"] = vars

    # Set up test cases.
    tests = {}

    config[":TESTS:"] = tests

    # Set up 'allways' makefile code.
    allways = {}

    config[":ALLWAYS:"] = allways



def parse_flag_contents(config, contents, start_line, end_line):

    if contents[start_line] == ":ENVIRONMENT:":

        return

    if contents[start_line] == ":VARS:":

        return

    if contents[start_line] == ":TESTS:":

        return

    if contents[start_line] == ":ALLWAYS:":

        return


# ======= Entry Point ========
if __name__ == "__main__":
    main()
